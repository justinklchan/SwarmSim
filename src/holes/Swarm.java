package holes;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Random;
import javax.imageio.ImageIO;
import javax.swing.JPanel;
import javax.swing.Timer;

/**
 *
 * @author chanjustin
 */
public class Swarm extends javax.swing.JFrame {

    static int BLACK = 0;
    static int WHITE = 1;
    static int RED = 2;
    /**
     * Creates new form Swarm
     */
    public Swarm() {
        initComponents();
    }

    public void act()
    {   
        for(Bot bot : IO.bots)
        {
            if(!bot.ended && !bot.stopIdGen)
            {
                bot.GenerateLocallyUniqueID();
            }
        }
        
        boolean stabilizedGradient = true;
        for(Bot bot : IO.bots)
        {
            if(!bot.ended && !bot.stopGradientFormation)
            {
                boolean modified = bot.GradientFormation();
                if(modified == true)
                {
                    stabilizedGradient = false;
                }
            }
        }
        
        boolean stabilizedLocalization = true;
        for(Bot bot : IO.bots)
        {
            if(!bot.ended && !bot.stopLocalization)
            {
                boolean modified = bot.Localization();
                if(modified == true)
                {
                    stabilizedLocalization = false;
                }
            }
        }
        
        if(stabilizedGradient && stabilizedLocalization)
        {
            for(Bot bot : IO.bots)
            {
                if(!bot.ended && !bot.stopEdgeFollow)
                {
                    bot.EdgeFollow();
                }
            }
            
            for(Bot bot : IO.bots)
            {
                if(!bot.ended)
                {
                    bot.run();
                }
            }
        }
//        System.out.println("=========================");
    }
        
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        CustomPanel = new SimPanel();
        nextButton = new javax.swing.JButton();
        actNumber = new javax.swing.JLabel();
        startButton = new javax.swing.JButton();
        stopButton = new javax.swing.JButton();
        restartButton = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        CustomPanel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                CustomPanelMouseClicked(evt);
            }
        });

        nextButton.setText("Next");
        nextButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nextButtonActionPerformed(evt);
            }
        });

        startButton.setText("Start");
        startButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startButtonActionPerformed(evt);
            }
        });

        stopButton.setText("Stop");
        stopButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                stopButtonActionPerformed(evt);
            }
        });

        restartButton.setText("Restart");
        restartButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                restartButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout CustomPanelLayout = new javax.swing.GroupLayout(CustomPanel);
        CustomPanel.setLayout(CustomPanelLayout);
        CustomPanelLayout.setHorizontalGroup(
            CustomPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(CustomPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(actNumber, javax.swing.GroupLayout.PREFERRED_SIZE, 90, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, CustomPanelLayout.createSequentialGroup()
                .addGap(0, 422, Short.MAX_VALUE)
                .addComponent(restartButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(startButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(stopButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(nextButton)
                .addGap(10, 10, 10))
        );
        CustomPanelLayout.setVerticalGroup(
            CustomPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(CustomPanelLayout.createSequentialGroup()
                .addGroup(CustomPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(nextButton)
                    .addComponent(startButton)
                    .addComponent(stopButton)
                    .addComponent(restartButton))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 364, Short.MAX_VALUE)
                .addComponent(actNumber, javax.swing.GroupLayout.PREFERRED_SIZE, 17, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(CustomPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(CustomPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void nextButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nextButtonActionPerformed
        for(int i = 0; i < actInc; i++)
        {
            act();
            actNum += 1;
        }
    }//GEN-LAST:event_nextButtonActionPerformed

    private void CustomPanelMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_CustomPanelMouseClicked
        int x = evt.getX();
        int y = evt.getY();
        for(Bot bot : IO.graphicsCoords.keySet())
        {
            Point2D pt = IO.graphicsCoords.get(bot);
            int tol = 3;
            if(Math.abs(pt.getX()-x) < tol && Math.abs(pt.getY()-y) < tol)
            {
                System.out.println(bot.seqNum);
            }
        }
    }//GEN-LAST:event_CustomPanelMouseClicked

    private void startButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startButtonActionPerformed
        drawTimer.start();
    }//GEN-LAST:event_startButtonActionPerformed

    private void stopButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_stopButtonActionPerformed
        drawTimer.stop();
    }//GEN-LAST:event_stopButtonActionPerformed

    private void restartButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_restartButtonActionPerformed
        restart();
        actNumber.setText(actNum+"");
        spawned = false;
        repaint();
    }//GEN-LAST:event_restartButtonActionPerformed
    
    int actInc;
    int actNum;
    boolean spawned = false;
    String shapeFile;
    boolean drawShape;
    Timer drawTimer;
        
    public void restart()
    {
        IO.bots = new ArrayList<Bot>(1000);
        IO.botCoords = new HashMap<Bot,Point2D>(1000);
        IO.graphicsCoords = new HashMap<Bot,Point2D>(1000);
        actNum = 0;
    }
    
    int[][] img;
        
    class SimPanel extends JPanel
    {
        int RAND_SEED = 20;
        Random random;
        
        int botSize;
        double MAX_GRADIENT;
        int s;
        
        Color[] gradientColors;
        Color[] stateColors;
        
        public SimPanel()
        {
            super();
            
            //DEMO 1 holey object
            shapeFile = "src/holes-working.bmp";
            drawShape = false;
            MAX_GRADIENT = 17;
            
            //DEMO 2 draw R
//            SHAPE_FILE = "src/R.bmp";
//            drawShape = true;
//            MAX_GRADIENT = 30;
//            numBots = (int)Math.pow(11,2);
            
            //DEMO 3 (too many bots)
//            SHAPE_FILE = "src/R.bmp";
//            drawShape = false;
//            MAX_GRADIENT = 30;
//            numBots = (int)Math.pow(12,2);
            
            //DEMO 4 draw olympic
//            SHAPE_FILE = "src/olympic.bmp";
//            drawShape = true;
//            MAX_GRADIENT = 30;
//            numBots = (int)Math.pow(11,2);
            
            random = new Random(RAND_SEED);
            restart();
            stateColors = new Color[State.values().length];
            stateColors[0] = Color.black;
            stateColors[1] = Color.red;
            stateColors[2] = Color.blue;
            stateColors[3] = Color.orange;
            stateColors[4] = Color.green;
            drawTimer = new Timer(10, taskPerformer);
            drawTimer.start();
        }
        
        boolean checkAllHaveLeftCluster = true;
        boolean allHaveMoved;
        ActionListener taskPerformer = new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                for(int i = 0; i < actInc; i++)
                {
                    act();
                    actNum += 1;
                }
                actNumber.setText(actNum+"");
                repaint();
            }
        };
        
        @Override
        public void paintComponent(Graphics g) {
            super.paintComponent(g);
            if(!spawned)
            {
                gradientColors = new Color[(int)MAX_GRADIENT];
                for(int i = 0; i < MAX_GRADIENT; i++)
                {
                    gradientColors[i] = new Color(random.nextInt(256),random.nextInt(256),random.nextInt(256));
                }
                
                s = 2;
                int sx = 200;
                int sy = 150*s;
                botSize = 5*s;
                actInc = 10;
                
                int wBots = 15;
                int hBots = 15;
                int w = botSize*wBots;
                int h = botSize*hBots;
                
                int x = sx-botSize-(wBots-1)*botSize;
                int y = sy+botSize-(hBots-1)*botSize;
                
                img = readShape(shapeFile, s,s);
                setSeed(sx,sy,s);
                packSpawnInArea(sx, sy+botSize, x, y, w, h, img, s);
                
                for(int i = 0; i < IO.bots.size(); i++)
                {
                    IO.bots.get(i).seqNum = i;
                }
                spawned = true;
            }
            
            Font tr = new Font("helvetica", Font.PLAIN, 8);
            g.setFont(tr);
            
            if(drawShape)
            {
                drawShape(g,img,200,60*s);
            }
            drawBots(g);
        }
        
        public void drawBots(Graphics g)
        {
            for(Bot bot : IO.bots)
            {
                if(bot.seed)
                {
                    g.setColor(Color.green);
                }
                else if(bot.state != State.JOINED_SHAPE)
                {
                    int c = (int)((bot.gradientValue/(MAX_GRADIENT+1))*255);
                    g.setColor(new Color(c,0,0));
                }
                else
                {
//                    g.setColor(stateColors[bot.state.ordinal()]);
//                    g.setColor(gradientColors[bot.gradientValue]);
                    int c = (int)((bot.gradientValue/(MAX_GRADIENT+1))*255);
                    g.setColor(new Color(0,c,0));
                }
                
                if(bot.state == State.JOINED_SHAPE)
                {
                    g.fillRect((int)IO.graphicsCoords.get(bot).getX(), (int)IO.graphicsCoords.get(bot).getY(), botSize, botSize);
                }
                else
                {
                    g.fillOval((int)IO.graphicsCoords.get(bot).getX(), (int)IO.graphicsCoords.get(bot).getY(), botSize, botSize);
                }
                g.setColor(Color.white);
                g.drawString(bot.gradientValue+"", (int)IO.graphicsCoords.get(bot).getX()+2, 
                             (int)IO.graphicsCoords.get(bot).getY()+7);
            }
        }
        
        //we set 4 seeds, one is the gradient seed
        public void setSeed(int x, int y, int s)
        {
            int xIncrement = botSize;
            int yIncrement = botSize;
            int seedCount = 0;
            
            for(int i = 0; i <= 1; i += 1)
            {
                for(int j = 0; j <= 1; j += 1)
                {
                    Bot bot = new Bot(img, s, true, botSize);
                    bot.localized = true;
                    
//                    //this is the global coordinates
                    double gx = x+i*xIncrement;
                    double gy = y+j*yIncrement;
                    IO.graphicsCoords.put(bot, new Point2D.Double(gx,gy));
                        
                    double px = 0;
                    double py = 0;
                    if(seedCount == 0)
                    {
                        px = 0;
                        py = botSize;
                    }
                    else if(seedCount == 1)
                    {
                        px = 0;
                        py = 0;
                    }
                    else if(seedCount == 2)
                    {
                        px = botSize;
                        py = botSize;
                    }
                    else
                    {
                        px = botSize;
                        py = 0;
                    }
                    bot.position = new Point2D.Double(px,py);
                    IO.botCoords.put(bot,new Point2D.Double(px,py));
                    seedCount += 1;
                    
                    IO.bots.add(bot);
                }
            }
            IO.bots.get(IO.bots.size()-1).gradientSeed = true;
        }
        
        //pack bots in a given area
        public void packSpawnInArea(int sx, int sy, int startX, int startY, int width, int height, int[][] imgRep, int s)
        {
            int xTimes = width/botSize;
            int yTimes = height/botSize;
            
            for(int i = 0; i < xTimes; i++)
            {
                for(int j = 0; j < yTimes; j++)
                {
                    Bot bot = new Bot(imgRep,s,false,botSize);
                    IO.bots.add(bot);
                    double gx = startX+botSize*i;
                    double gy = (startY+botSize*j);
                    IO.graphicsCoords.put(bot, new Point2D.Double(gx,gy));
                    
                    double x = gx-sx;
                    double y = -(gy-sy);
                    IO.botCoords.put(bot,new Point2D.Double(x,y));
                }
            }
        }
        
        //draw shape
        public void drawShape(Graphics g, int[][] shape, int tx, int ty)
        {
            for(int i = 0; i < shape.length; i++)
            {
                for(int j = 0; j < shape[i].length; j++)
                {
                    if(shape[i][j] == BLACK || shape[i][j] == RED)
                    {
                        if(shape[i][j] == RED)
                        {
                            g.setColor(Color.red);
                        }
                        else if(shape[i][j] == BLACK)
                        {
                            g.setColor(Color.black);
                        }
                        g.drawRect(j+tx, i+ty, 1, 1);
                    }
                }
            }
        }
        
        public void translate(int[][] shape, int tx, int ty)
        {
            if(tx > 0)
            {
                //for every row
                for(int i = 0; i < shape.length; i++)
                {
                    for(int j = shape[i].length-1-tx; j >= 0; j--)
                    {
                        //shift elements in y direction
                        shape[i][j+tx] = shape[i][j];
                        shape[i][j] = 1;
                    }
                }
            }
            
            if(ty > 0)
            {
                //for every row
                for(int i = shape.length-1; i >= ty; i--)
                {
                    for(int j = 0; j < shape[i].length; j++)
                    {
                        shape[i][j] = shape[i-ty][j];
                        shape[i-ty][j] = 1;
                    }
                }
            }
        }
    }
    
        
    //scales image by a certain amount
    //http://stackoverflow.com/questions/4216123/how-to-scale-a-bufferedimage
    public BufferedImage scale(BufferedImage before, double sx, double sy)
    {
        int w = before.getWidth();
        int h = before.getHeight();
        BufferedImage after = new BufferedImage((int)(w*sx), (int)(h*sy), BufferedImage.TYPE_INT_ARGB);
        for(int i = 0; i < w; i++)
        {
            for(int j = 0; j < h; j++)
            {
                after.setRGB(i, j, convertToRGB(Color.white));
            }
        }
        AffineTransform at = new AffineTransform();
        at.scale(sx, sy);
        AffineTransformOp scaleOp = 
           new AffineTransformOp(at, AffineTransformOp.TYPE_BILINEAR);
        after = scaleOp.filter(before, after);
        return after;
    }

    public int convertToRGB(Color c)
    {
        return ((c.getRed()&0x0ff)<<16)|((c.getGreen()&0x0ff)<<8)|(c.getBlue()&0x0ff);
    }

    public Color convertToColor(int c)
    {
        return new Color(c);
    }

    //reads shape from file as bufferedimage, stored as int[][]
    //image can be scaled by sx/sy
    //image can be translated by tx/ty
    //array is 0 for black, 1 for white
    public int[][] readShape(String shapeFile, double sx, double sy)
    {
        BufferedImage image = null;
        try
        {
            image = ImageIO.read(new File(shapeFile));
            image = scale(image,sx,sy);
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
        int[][] shape = new int[image.getHeight()][image.getWidth()];
        for(int i = 0; i < image.getHeight(); i++)
        {
            for(int j = 0; j < image.getWidth(); j++)
            {
                shape[i][j] = WHITE;
            }
        }

        //converting from bufferedimage to int[][]
        for(int i = 0; i < image.getHeight(); i++)
        {
            for(int j = 0; j < image.getWidth(); j++)
            {
                Color c = convertToColor(image.getRGB(i, j));
                if(c.equals(Color.black))
                {
                    shape[j][i] = BLACK;
                }
                else if(c.getRed()>c.getGreen())
                {
                    shape[j][i] = RED;
                }
            }
        }
        return shape;
    }
        
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Swarm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Swarm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Swarm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Swarm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Swarm().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel CustomPanel;
    private javax.swing.JLabel actNumber;
    private javax.swing.JButton nextButton;
    private javax.swing.JButton restartButton;
    private javax.swing.JButton startButton;
    private javax.swing.JButton stopButton;
    // End of variables declaration//GEN-END:variables
}
